<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover">
<meta name="theme-color" content="#3a3a44">
<title>A Gift of Time</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600&family=Lateef:wght@400&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#1a1a22;touch-action:none;user-select:none;-webkit-user-select:none}
canvas{display:block;width:100%;height:100%}
#vignette{position:fixed;inset:0;pointer-events:none;z-index:5;opacity:0;transition:opacity 1.5s;background:radial-gradient(ellipse at center,transparent 40%,rgba(0,0,0,0.7) 100%)}
#info{position:fixed;bottom:env(safe-area-inset-bottom,12px);left:0;right:0;text-align:center;font-family:'Inter',system-ui,sans-serif;pointer-events:none;z-index:10;padding:0 16px 12px;opacity:0;transition:opacity .4s}
#info.visible{opacity:1}
#info .hijri{font-size:14px;font-weight:500;letter-spacing:.5px}
#info .greg{font-size:11px;font-weight:300;margin-top:2px}
#info .surah{font-size:10px;font-weight:200;letter-spacing:1.5px;text-transform:uppercase;margin-top:6px;opacity:0.6}
#dialBar{position:fixed;bottom:calc(env(safe-area-inset-bottom,0px) + 50px);left:0;right:0;display:flex;justify-content:center;gap:6px;opacity:0;transition:opacity .4s;z-index:10;pointer-events:none}
#dialBar.visible{opacity:1;pointer-events:auto}
.dial-dot{width:7px;height:7px;border-radius:50%;border:1.5px solid rgba(255,255,255,.3);cursor:pointer;transition:all .3s}
.dial-dot.active{border-color:rgba(255,255,255,.8);background:rgba(255,255,255,.5)}
#modeToggle{position:fixed;top:calc(env(safe-area-inset-top,12px) + 12px);right:16px;z-index:10;opacity:0;transition:opacity .4s;pointer-events:none;cursor:pointer;background:none;border:none;padding:8px}
#modeToggle.visible{opacity:1;pointer-events:auto}
#modeToggle svg{width:22px;height:22px;stroke-width:1;fill:none;stroke:currentColor;transition:color .4s}
</style>
</head>
<body>
<div id="vignette"></div>
<button id="modeToggle" aria-label="Toggle day/night"><svg id="modeIcon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5" /><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button>
<div id="info"><div class="hijri" id="hijri"></div><div class="greg" id="greg"></div><div class="surah" id="surah"></div></div>
<div id="dialBar">
  <div class="dial-dot" data-dial="tennis" style="border-color:#68b890"></div>
  <div class="dial-dot" data-dial="white" style="border-color:#e8e4dc"></div>
  <div class="dial-dot" data-dial="salmon" style="border-color:#d8988c"></div>
  <div class="dial-dot active" data-dial="slate" style="border-color:#6a6a74"></div>
  <div class="dial-dot" data-dial="sky" style="border-color:#82b8d8"></div>
  <div class="dial-dot" data-dial="kawthar" style="border-color:#f2dce0"></div>
  <div class="dial-dot" data-dial="dhuha" style="border-color:#f08040"></div>
  <div class="dial-dot" data-dial="najm" style="border-color:#384870"></div>
  <div class="dial-dot" data-dial="qamar" style="border-color:#c0c4cc"></div>
  <div class="dial-dot" data-dial="ward" style="border-color:#d89098"></div>
  <div class="dial-dot" data-dial="lilas" style="border-color:#8878a8"></div>
  <div class="dial-dot" data-dial="rainbow" style="border-color:#1a1a1a;background:linear-gradient(135deg,#ff4040,#ff8c00,#ffd700,#40c040,#4090ff,#8040c0)"></div>
</div>

<script type="importmap">
{ "imports": { "three": "https://esm.sh/three@0.170.0", "three/addons/": "https://esm.sh/three@0.170.0/examples/jsm/" } }
</script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// ══════════════════════════════════════════
// CONFIG
// ══════════════════════════════════════════
const DIALS = {
  tennis: {bg:0x68b890, lume:0xf0f0e8, hand:0xf0f0e8, sec:0xffffff, text:'#f0f0e8', surah:'Ar-Raḥmān'},       // pistachio sorbet
  white:  {bg:0xe8e4dc, lume:0xd4708c, hand:0xd4708c, sec:0xd4708c, text:'#d4708c', surah:'An-Nūr'},           // Nurjaan's dial — white + rose pink everything
  salmon: {bg:0xd8988c, lume:0xf8f0ec, hand:0xf8f0ec, sec:0xffffff, text:'#f8f0ec', surah:'Ash-Shams'},        // peach sorbet
  slate:  {bg:0x585860, lume:0xe8e0c8, hand:0xd0d0d4, sec:0xff6633, text:'#e8e0c8', surah:'Al-Layl'},          // grey + cream + orange sec — the anchor
  sky:    {bg:0x82b8d8, lume:0xf0f4f8, hand:0xf0f4f8, sec:0xffffff, text:'#f0f4f8', surah:'Al-Burūj'},         // blueberry sorbet
  kawthar:{bg:0xf2dce0, lume:0xc88898, hand:0xc88898, sec:0xc88898, text:'#9a6878', surah:'Al-Kawthar'},        // strawberry + rose gold
  dhuha:  {bg:0xf08040, lume:0xffffff, hand:0xffffff, sec:0xffffff, text:'#ffffff', surah:'Aḍ-Ḍuḥā'},           // bright orange sorbet
  najm:   {bg:0x384870, lume:0xe0e8f4, hand:0xe0e8f4, sec:0xffffff, text:'#e0e8f4', surah:'An-Najm'},          // blueberry sorbet — softer midnight
  qamar:  {bg:0xc0c4cc, lume:0x2a2a30, hand:0x1a1a20, sec:0x2a4070, text:'#2a2a30', surah:'Al-Qamar'},         // silver — the neutral
  ward:   {bg:0xd89098, lume:0xf8f0f0, hand:0xf8f0f0, sec:0xffffff, text:'#f8f0f0', surah:'Al-Wāqiʿah'},       // raspberry sorbet
  lilas:  {bg:0x8878a8, lume:0xf0ecf4, hand:0xf0ecf4, sec:0xffffff, text:'#f0ecf4', surah:'Al-Mulk'},           // lavender sorbet
  rainbow:{bg:0x1a1a1a, lume:0xc8a878, hand:0xc8a878, sec:0xc8a878, text:'#c8a878', surah:'Al-Insān', bezel:true}, // Rolex Rainbow — black dial + rose gold
};
// Night lume palettes — modeled after real SuperLuminova variants
// Each matches the daytime lume character but amplified for glow
const NIGHT_LUME = {
  tennis: { emissive: 0x88ff30 },  // C1 — vivid green, gardens glowing at night
  white:  { emissive: 0xffa0c0 },  // Nurjaan — soft rose pink lume
  salmon: { emissive: 0xffc070 },  // Old radium — warm amber, sunset afterglow
  slate:  { emissive: 0xc8e8a0 },  // C3 — classic green-cream, the iconic lume
  sky:    { emissive: 0x80d0ff },  // BGW9 — ice blue constellations
  kawthar:{ emissive: 0xffa0c0 },  // Soft pink glow
  dhuha:  { emissive: 0xffc040 },  // Warm golden sunrise
  najm:   { emissive: 0x90b8ff },  // Cool stellar blue
  qamar:  { emissive: 0xe8f0ff },  // Bright ice-silver moonbeam
  ward:   { emissive: 0xff80a8 },  // Warm rose glow
  lilas:  { emissive: 0xc090ff },  // Purple lume
  rainbow:{ emissive: 0xf0d8a0 },  // Warm champagne
};
const DIAL_NAMES = Object.keys(DIALS);
const ARABIC = ['١٢','١','٢','٣','٤','٥','٦','٧','٨','٩','١٠','١١'];

// ── Lateef Arabic numeral glyph paths (extracted via opentype.js, centered at origin) ──
// Keys: twelve(12), two(2), four(4), eight(8), ten(10) — NOMOS Campus layout
const NUMERAL_PATHS = {"twelve":{"a":"١٢","w":63.14,"h":48.53,"c":[["M",-31.57,24.26],["L",-31.57,-24.26],["L",-20.84,-24.26],["L",-20.84,24.26],["L",-31.57,24.26],["Z"],["M",13.43,24.26],["L",-1.69,-17.42],["L",-1.69,-24.26],["L",31.57,-24.26],["L",31.57,-15.12],["L",10.12,-15.12],["L",24.8,24.26],["L",13.43,24.26],["Z"]]},"two":{"a":"٢","w":33.26,"h":48.53,"c":[["M",-1.51,24.26],["L",-16.63,-17.42],["L",-16.63,-24.26],["L",16.63,-24.26],["L",16.63,-15.12],["L",-4.82,-15.12],["L",9.86,24.26],["L",-1.51,24.26],["Z"]]},"four":{"a":"٤","w":30.82,"h":51.12,"c":[["M",2.3,25.56],["L",2.3,25.56],["Q",-0.07,25.56,-2.27,25.2],["Q",-4.46,24.84,-6.48,24.12],["L",-6.48,24.12],["Q",-10.58,22.68,-13,20.34],["Q",-15.41,18,-15.41,15.7],["L",-15.41,15.7],["Q",-15.41,13.03,-13.43,10.62],["Q",-11.45,8.21,-8.24,5.83],["Q",-5.04,3.46,-1.44,1.08],["L",-1.44,1.08],["L",-5.11,-1.94],["Q",-6.91,-3.46,-8.24,-4.68],["Q",-9.58,-5.9,-10.51,-6.91],["Q",-11.45,-7.92,-11.92,-8.68],["Q",-12.38,-9.43,-12.38,-10.01],["L",-12.38,-10.01],["Q",-12.38,-10.94,-11.59,-12.17],["Q",-10.8,-13.39,-9.22,-14.9],["L",-9.22,-14.9],["Q",-7.06,-16.92,-4.03,-18.94],["Q",-1.01,-20.95,2.59,-22.68],["Q",6.19,-24.41,9.94,-25.56],["L",9.94,-25.56],["L",12.6,-16.56],["Q",11.02,-16.06,9.4,-15.44],["Q",7.78,-14.83,6.19,-14.11],["L",6.19,-14.11],["Q",4.54,-13.39,2.7,-12.38],["Q",0.86,-11.38,-0.4,-10.55],["Q",-1.66,-9.72,-1.66,-9.29],["L",-1.66,-9.29],["Q",-1.66,-9.07,-0.61,-8.14],["Q",0.43,-7.2,2.16,-5.83],["Q",3.89,-4.46,6.05,-2.81],["Q",8.21,-1.15,10.44,0.58],["L",10.44,0.58],["Q",6.26,3.46,3.64,5.36],["Q",1.01,7.27,-0.22,8.28],["L",-0.22,8.28],["Q",-2.23,9.86,-3.67,11.41],["Q",-5.11,12.96,-5.11,13.9],["L",-5.11,13.9],["Q",-5.11,14.83,-3.56,15.48],["Q",-2.02,16.13,0.07,16.42],["Q",2.16,16.7,3.89,16.7],["L",3.89,16.7],["Q",6.98,16.7,9.86,16.27],["Q",12.74,15.84,15.41,15.05],["L",15.41,15.05],["L",15.41,23.83],["Q",12.89,24.7,9.61,25.13],["Q",6.34,25.56,2.3,25.56],["Z"]]},"eight":{"a":"٨","w":38.81,"h":48.53,"c":[["M",-19.4,24.26],["L",-5.51,-24.26],["L",5.51,-24.26],["L",19.4,24.26],["L",8.17,24.26],["L",1.69,-3.02],["Q",1.48,-4.03,1.12,-6.05],["Q",0.76,-8.06,0.47,-10.12],["Q",0.18,-12.17,0.11,-13.25],["L",0.11,-13.25],["L",-0.11,-13.25],["Q",-0.18,-11.88,-0.4,-10.26],["Q",-0.61,-8.64,-0.9,-6.84],["Q",-1.19,-5.04,-1.69,-3.02],["L",-1.69,-3.02],["L",-8.17,24.26],["L",-19.4,24.26],["Z"]]},"ten":{"a":"١٠","w":56.81,"h":48.53,"c":[["M",-28.4,24.26],["L",-28.4,-24.26],["L",-17.68,-24.26],["L",-17.68,24.26],["L",-28.4,24.26],["Z"],["M",19.26,8.86],["L",7.74,-2.74],["L",16.81,-11.81],["L",28.4,-0.29],["L",19.26,8.86],["Z"]]}};

// Convert opentype path commands → Three.js Shapes
// Arabic glyphs have multiple separate strokes — each is its own shape, NOT holes.
// Holes only exist when one contour is CW inside a CCW contour (or vice versa).
function pathToShapes(pathData, scale) {
  const contours = [];
  let pts = [];
  for (const cmd of pathData.c) {
    switch(cmd[0]) {
      case 'M':
        if (pts.length > 2) contours.push(pts);
        pts = [{x: cmd[1]*scale, y: -cmd[2]*scale}];
        break;
      case 'L':
        pts.push({x: cmd[1]*scale, y: -cmd[2]*scale});
        break;
      case 'Q': {
        // Approximate quadratic bezier with line segments
        const prev = pts[pts.length-1];
        for (let t = 0.25; t <= 1; t += 0.25) {
          const mt = 1-t;
          pts.push({
            x: mt*mt*prev.x + 2*mt*t*(cmd[1]*scale) + t*t*(cmd[3]*scale),
            y: mt*mt*prev.y + 2*mt*t*(-cmd[2]*scale) + t*t*(-cmd[4]*scale)
          });
        }
        break;
      }
      case 'C': {
        const prev = pts[pts.length-1];
        for (let t = 0.2; t <= 1; t += 0.2) {
          const mt = 1-t;
          pts.push({
            x: mt*mt*mt*prev.x + 3*mt*mt*t*(cmd[1]*scale) + 3*mt*t*t*(cmd[3]*scale) + t*t*t*(cmd[5]*scale),
            y: mt*mt*mt*prev.y + 3*mt*mt*t*(-cmd[2]*scale) + 3*mt*t*t*(-cmd[4]*scale) + t*t*t*(-cmd[6]*scale)
          });
        }
        break;
      }
      case 'Z':
        if (pts.length > 2) contours.push(pts);
        pts = [];
        break;
    }
  }
  if (pts.length > 2) contours.push(pts);
  
  // Compute signed area for each contour (positive = CCW, negative = CW)
  const measured = contours.map(pts => {
    let area = 0;
    for (let j = 0; j < pts.length; j++) {
      const k = (j+1) % pts.length;
      area += pts[j].x * pts[k].y - pts[k].x * pts[j].y;
    }
    return { pts, area: area/2 };
  }).filter(m => Math.abs(m.area) > 0.5); // skip degenerate
  
  if (!measured.length) return [];
  
  // Simple approach: all contours become independent shapes
  // (Arabic numerals don't have traditional holes like Latin 'O' or '4')
  return measured.map(m => {
    const shape = new THREE.Shape();
    shape.moveTo(m.pts[0].x, m.pts[0].y);
    for (let i = 1; i < m.pts.length; i++) {
      shape.lineTo(m.pts[i].x, m.pts[i].y);
    }
    shape.closePath();
    return shape;
  });
}

// URL params
const _P = new URLSearchParams(location.search);
const EMBED = _P.has('embed');
let currentDial = (_P.get('dial') && DIALS[_P.get('dial')]) ? _P.get('dial') : 'slate';
const NIGHT_START = _P.has('night');
let modeBlend = NIGHT_START ? 1 : 0, modeTarget = NIGHT_START ? 1 : 0;
let PD = null;
function pM(s){if(!s)return 0;const[h,m]=s.split(':').map(Number);return h*60+m;}

// ══════════════════════════════════════════
// RENDERER — direct render, no post-processing
// ══════════════════════════════════════════
let W = window.innerWidth, H = window.innerHeight;
const R = 80; // world-space radius

const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference:'high-performance', alpha: EMBED && !NIGHT_START });
renderer.samples = 4;
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 3));
renderer.setSize(W, H);
renderer.shadowMap.enabled = false;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();

// ── Perspective camera (slight top-down angle for depth)
// Adjust camera distance based on aspect ratio so clock fits both portrait and landscape
const aspect = W/H;
const camZ = 280;
const cam = new THREE.PerspectiveCamera(32, aspect, 1, 2000);
cam.position.set(0, -3, camZ);
cam.lookAt(0, 0, 0);

// ══════════════════════════════════════════
// BLOOM POST-PROCESSING
// ══════════════════════════════════════════
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, cam));
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(W, H),
  0.0,   // strength — will animate with modeBlend
  0.4,   // radius — soft spread
  0.85   // threshold — only bright emissives bloom
);
composer.addPass(bloomPass);

// ══════════════════════════════════════════
// LIGHTING — NOMOS-style watch photography
// Low-intensity HDRI for hand reflections. Env rotates with tilt.
// Dial stays calm (BasicMaterial). Hands catch sweeping softbox light.
// ══════════════════════════════════════════
const { RectAreaLightUniformsLib } = await import('three/addons/lights/RectAreaLightUniformsLib.js');
RectAreaLightUniformsLib.init();

// ── Studio HDRI at controlled intensity ──
let studioEnvMap;
{
  const { RGBELoader } = await import('three/addons/loaders/RGBELoader.js');
  const pmrem = new THREE.PMREMGenerator(renderer);
  pmrem.compileEquirectangularShader();
  const hdrTex = await new Promise((resolve, reject) => {
    new RGBELoader().load('studio.hdr', resolve, undefined, reject);
  });
  const envRT = pmrem.fromEquirectangular(hdrTex);
  studioEnvMap = envRT.texture;
  scene.environment = studioEnvMap;
  scene.environmentIntensity = 0.6; // dial is BasicMaterial (unaffected), cranked for PBR subdial visibility
  scene.environmentRotation = new THREE.Euler(0.1, 0.3, 0); // start offset — softbox pre-positioned for hand reflections at rest
  hdrTex.dispose();
  pmrem.dispose();
}

// Ambient — minimal shadow fill
const ambLight = new THREE.AmbientLight(0xffffff, 0.12);
scene.add(ambLight);

// Key light — soft rect from upper-left (warm, even illumination)
const keyLight = new THREE.RectAreaLight(0xfff8f0, 1.0, 250, 250);
keyLight.position.set(-60, 150, 220);
keyLight.lookAt(0, 0, 0);
scene.add(keyLight);

// Spec point — tilt-tracking accent highlight on hands
const specPoint = new THREE.PointLight(0xffffff, 3, 300, 2);
specPoint.position.set(30, 60, 180);
scene.add(specPoint);

// Counter spec — opposite warmth for depth
const counterSpec = new THREE.PointLight(0xfff0e0, 1.0, 400, 2);
counterSpec.position.set(-40, -30, 200);
scene.add(counterSpec);

// Subdial spot — wider cone to illuminate subdial face + glass sparkle
const subSpot = new THREE.SpotLight(0xffffff, 12, 400, Math.PI/8, 0.5, 1.5);
subSpot.position.set(5, -R*0.5 + 20, 150);
subSpot.target.position.set(0, -R*0.5, 0);
scene.add(subSpot);
scene.add(subSpot.target);


// ══════════════════════════════════════════
// MATERIALS (PBR)
// ══════════════════════════════════════════

// ── Procedural grain texture (NOMOS-style sandblasted dial finish) ──
// Generates a roughness map with fine per-pixel noise so the dial
// responds subtly to tilt as HDRI sweeps across the micro-texture.
function makeGrainTexture(size = 512, baseVal = 235, spread = 20) {
  const c = document.createElement('canvas');
  c.width = c.height = size;
  const ctx = c.getContext('2d');
  const img = ctx.createImageData(size, size);
  for (let i = 0; i < img.data.length; i += 4) {
    const v = Math.max(0, Math.min(255, baseVal + (Math.random() - 0.5) * spread));
    img.data[i] = img.data[i+1] = img.data[i+2] = v;
    img.data[i+3] = 255;
  }
  ctx.putImageData(img, 0, 0);
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(2, 2); // tile for finer grain
  return tex;
}
const dialGrainTex = makeGrainTexture(512, 235, 20);     // standard dials: high roughness grain
const metalGrainTex = makeGrainTexture(256, 140, 15);    // qamar/kawthar: subtler, lower roughness grain

// ── Procedural bump map for applied numerals ──
// Renders numeral outlines to a canvas, used as bumpMap to fake depth
function makeNumeralBumpMap(numerals, font, size = 512) {
  const c = document.createElement('canvas');
  c.width = c.height = size;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, size, size);
  // Numerals will be painted white = raised
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const R = size * 0.42; // numeral ring radius
  const cx = size / 2, cy = size / 2;
  const positions = { // hour -> angle (0=12 o'clock, clockwise)
    12: 0, 2: 60, 10: 300, // Arabic numerals
    // 4 (IV) and 8 (VIII) handled as Roman — skip for bump (they're separate meshes)
  };
  ctx.font = `bold ${size * 0.09}px Inter, sans-serif`;
  for (const [hour, angleDeg] of Object.entries(positions)) {
    const a = (angleDeg - 90) * Math.PI / 180;
    const x = cx + Math.cos(a) * R;
    const y = cy + Math.sin(a) * R;
    ctx.fillText(hour.toString(), x, y);
  }
  // Roman numerals
  ctx.font = `${size * 0.07}px Inter, sans-serif`;
  const romans = { 'VIII': 240, 'IV': 120 };
  for (const [text, angleDeg] of Object.entries(romans)) {
    const a = (angleDeg - 90) * Math.PI / 180;
    const x = cx + Math.cos(a) * R;
    const y = cy + Math.sin(a) * R;
    ctx.fillText(text, x, y);
  }
  // Stick markers at odd hours (1,3,5,7,9,11)
  const stickHours = [1, 3, 5, 7, 9, 11];
  for (const h of stickHours) {
    if (h === 6) continue; // subdial
    const a = (h * 30 - 90) * Math.PI / 180;
    const inner = R - size * 0.03;
    const outer = R + size * 0.015;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = size * 0.006;
    ctx.beginPath();
    ctx.moveTo(cx + Math.cos(a) * inner, cy + Math.sin(a) * inner);
    ctx.lineTo(cx + Math.cos(a) * outer, cy + Math.sin(a) * outer);
    ctx.stroke();
  }
  const tex = new THREE.CanvasTexture(c);
  return tex;
}
const numeralBumpTex = makeNumeralBumpMap();

function dialMat(color) {
  const cd = currentDial;
  const special = {
    kawthar: { roughness:0.6, metalness:0.15, sheen:0.8, sheenColor:0xd4909a, sheenRoughness:0.3, clearcoat:0.6, clearcoatRoughness:0.3 },
    qamar:   { roughness:0.35, metalness:0.4, sheen:0, sheenColor:0x000000, sheenRoughness:0.8, clearcoat:0.2, clearcoatRoughness:0.2 },
  };
  const s = special[cd] || { roughness:0.95, metalness:0.0, sheen:0, sheenColor:0x000000, sheenRoughness:0.8, clearcoat:0, clearcoatRoughness:0 };
  // Dial = MeshBasicMaterial: unlit, zero light interaction.
  // All light play happens on hands, markers, glass, subdial — not the dial face.
  return new THREE.MeshBasicMaterial({ color });
}
function metalMat(color) {
  const precious = ['kawthar','dhuha','qamar','rainbow'].includes(currentDial);
  const m = new THREE.MeshPhysicalMaterial({
    color,
    roughness: precious ? 0.05 : 0.08, // near-mirror polish — catches HDRI as bright streaks
    metalness: precious ? 0.8 : 0.6,
    clearcoat: 1.0,
    clearcoatRoughness: 0.05,
    reflectivity: precious ? 1.0 : 0.9
  });
  m.envMapIntensity = precious ? 6.0 : 5.0; // HERO — hands must visibly catch and release light as you tilt
  return m;
}
function lumeMat(color) {
  const m = new THREE.MeshStandardMaterial({ color, roughness: 0.5, metalness: 0.0, emissive: color, emissiveIntensity: 0 }); m.envMapIntensity = 0; return m; // lume = paint, no reflections
}
function secMat(color) {
  const m = new THREE.MeshStandardMaterial({ color, roughness: 0.1, metalness: 0.4, emissive: color, emissiveIntensity: 0 }); m.envMapIntensity = 3.0; return m; // second hand — glossy lacquer finish
}

// ══════════════════════════════════════════
// GEOMETRY HELPERS
// ══════════════════════════════════════════
function extrudedPill(w, h, depth) {
  const s = new THREE.Shape();
  const r = w/2;
  s.moveTo(-r, -h/2+r); s.quadraticCurveTo(-r,-h/2, 0,-h/2);
  s.quadraticCurveTo(r,-h/2, r,-h/2+r); s.lineTo(r,h/2-r);
  s.quadraticCurveTo(r,h/2, 0,h/2); s.quadraticCurveTo(-r,h/2, -r,h/2-r);
  s.closePath();
  return new THREE.ExtrudeGeometry(s, { depth, bevelEnabled:true, bevelThickness:0.3, bevelSize:0.2, bevelSegments:2 });
}

function extrudedLeaf(len, maxW, tailLen, depth, baseScale=1.0) {
  const s = new THREE.Shape(), hw=maxW/2, bw=hw*baseScale;
  s.moveTo(-bw*0.5, -tailLen);
  s.quadraticCurveTo(-bw, len*0.15, -bw, len*0.3);
  s.quadraticCurveTo(-hw*0.25, len*0.75, 0, len);
  s.quadraticCurveTo(hw*0.25, len*0.75, bw, len*0.3);
  s.quadraticCurveTo(bw, len*0.15, bw*0.5, -tailLen);
  s.closePath();
  return new THREE.ExtrudeGeometry(s, { depth, bevelEnabled:true, bevelThickness:0.4, bevelSize:0.3, bevelSegments:3 });
}

// NOMOS Club Campus sword hands — flat baton tapering to point, lume channel recessed
function nomosHand(len, baseW, tailLen, depth) {
  const s = new THREE.Shape();
  const hw = baseW / 2;
  const triH = baseW; // equilateral: height ≈ width
  const triStart = len - triH;
  // Start at tail bottom-left
  s.moveTo(-hw * 0.6, -tailLen);
  // Straight parallel sides up to triangle start
  s.lineTo(-hw, 0);
  s.lineTo(-hw, triStart);
  // Short equilateral triangle tip
  s.lineTo(0, len);
  s.lineTo(hw, triStart);
  // Back down
  s.lineTo(hw, 0);
  s.lineTo(hw * 0.6, -tailLen);
  s.closePath();
  return new THREE.ExtrudeGeometry(s, { depth, bevelEnabled: true, bevelThickness: 0.3, bevelSize: 0.2, bevelSegments: 2 });
}

// Lume channel — recessed strip in center of NOMOS hand
function nomosLume(len, baseW, depth) {
  const cw = baseW * 0.35; // channel width
  const hw = cw / 2;
  const startY = len * 0.33; // start one-third up from base
  const triH = baseW; // match nomosHand triangle height
  const endY = len - triH; // stop at triangle base
  const s = new THREE.Shape();
  s.moveTo(-hw, startY);
  s.lineTo(-hw, endY);
  s.lineTo(hw, endY);
  s.lineTo(hw, startY);
  s.closePath();
  return new THREE.ExtrudeGeometry(s, { depth: 1.5, bevelEnabled: false });
}

function makeTextSprite(text, font, size, color) {
  const dpr = 3;
  const w = size*Math.max(text.length,1)*1.3, h = size*1.6;
  const cv = document.createElement('canvas');
  cv.width = w*dpr; cv.height = h*dpr;
  const ctx = cv.getContext('2d');
  ctx.font = font.replace(/(\d+)px/,(_,n)=>(n*dpr)+'px');
  ctx.fillStyle = color;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(text, cv.width/2, cv.height/2);
  const tex = new THREE.CanvasTexture(cv);
  tex.minFilter = THREE.LinearFilter;
  const mat = new THREE.SpriteMaterial({map:tex, transparent:true, depthTest:false});
  const sp = new THREE.Sprite(mat);
  sp.scale.set(w, h, 1);
  return sp;
}

// ══════════════════════════════════════════
// GYROSCOPE PARALLAX
// ══════════════════════════════════════════
let gx=0, gy=0, tgx=0, tgy=0;
let gyroGranted = false;
function initGyro(){
  if(typeof DeviceOrientationEvent!=='undefined'&&typeof DeviceOrientationEvent.requestPermission==='function'){
    // iOS 13+: requires explicit permission via user gesture
    async function requestGyro(){
      if(gyroGranted) return;
      try {
        const s = await DeviceOrientationEvent.requestPermission();
        if(s==='granted'){
          gyroGranted=true;
          window.addEventListener('deviceorientation',onG);
          console.log('[gyro] iOS permission granted');
        } else {
          console.log('[gyro] iOS permission denied:', s);
        }
      } catch(err) {
        console.log('[gyro] iOS permission error:', err);
      }
    }
    // Attach to both click and touchend — covers all iOS gestures
    document.addEventListener('click', requestGyro, {once:false});
    document.addEventListener('touchend', requestGyro, {once:false});
    // Also try immediately in case already granted from a previous session
    DeviceOrientationEvent.requestPermission().then(s=>{
      if(s==='granted'){
        gyroGranted=true;
        window.addEventListener('deviceorientation',onG);
        console.log('[gyro] iOS already granted');
      }
    }).catch(()=>{}); // Expected to fail without gesture — that's fine
  } else if(typeof DeviceOrientationEvent!=='undefined') {
    // Android + non-iOS — just listen
    window.addEventListener('deviceorientation',onG);
    // Verify events actually fire
    let gotEvent = false;
    function checkGyro(e) {
      if(!gotEvent && e.gamma !== null) {
        gotEvent = true;
        console.log('[gyro] Events firing, gamma:', e.gamma);
      }
    }
    window.addEventListener('deviceorientation', checkGyro);
  }
  window.addEventListener('mousemove',e=>{tgx=((e.clientX/W)-0.5)*2;tgy=((e.clientY/H)-0.5)*2;});
}
// gyro debug removed
function onG(e){
  if(e.gamma===null)return;
  // gyro logging removed
  // Auto-calibrate: first few readings establish the user's natural hold angle
  if(!window._gyroCal) { window._gyroCal = { samples:[], done:false }; }
  if(!window._gyroCal.done) {
    window._gyroCal.samples.push({ g: e.gamma, b: e.beta });
    if(window._gyroCal.samples.length >= 15) {
      const avg = window._gyroCal.samples.reduce((a,s) => ({ g:a.g+s.g, b:a.b+s.b }), {g:0,b:0});
      window._gyroCal.restGamma = avg.g / window._gyroCal.samples.length;
      window._gyroCal.restBeta = avg.b / window._gyroCal.samples.length;
      window._gyroCal.done = true;
      console.log('[gyro] Calibrated rest position — gamma:', window._gyroCal.restGamma.toFixed(1), 'beta:', window._gyroCal.restBeta.toFixed(1));
    }
    return; // don't move until calibrated
  }
  const cal = window._gyroCal;
  tgx=Math.max(-1,Math.min(1,((e.gamma||0) - cal.restGamma)/25));
  tgy=Math.max(-1,Math.min(1,((e.beta||0) - cal.restBeta)/25));
  // Compass heading for qibla
  if(e.webkitCompassHeading !== undefined) {
    targetCompassHeading = e.webkitCompassHeading;
    hasCompassData = true;
  } else if(e.alpha !== null) {
    targetCompassHeading = (360 - e.alpha) % 360;
    hasCompassData = true;
  }
}
initGyro();

// ══════════════════════════════════════════
// BUILD CLOCK
// ══════════════════════════════════════════
// Background plane (fills screen, matches dial color)
// Background surround plane — flush with dial face, hole cut for gap
const CLOCK_SCALE = EMBED ? 0.65 : 0.50;
const bgCutoutR = R * 1.12 * CLOCK_SCALE; // flush with dial edge, no gap
const bgPlaneMat = new THREE.MeshBasicMaterial({ color: 0x1a1a22 }); // unlit — no light interaction
const bgShape = new THREE.Shape();
bgShape.moveTo(-1000, -1000); bgShape.lineTo(1000, -1000); bgShape.lineTo(1000, 1000); bgShape.lineTo(-1000, 1000); bgShape.closePath();
const bgHole = new THREE.Path();
bgHole.absarc(0, 0, bgCutoutR, 0, Math.PI*2, true);
bgShape.holes.push(bgHole);
const bgPlaneGeo = new THREE.ShapeGeometry(bgShape, 64);
const bgPlane = new THREE.Mesh(bgPlaneGeo, bgPlaneMat);
bgPlane.position.z = -3 * CLOCK_SCALE; // flush with dial front face in world space
if(!EMBED || NIGHT_START) scene.add(bgPlane);
if(EMBED && !NIGHT_START) { renderer.setClearColor(0x000000, 0); }

const clockGroup = new THREE.Group(); // everything lives here for parallax
clockGroup.scale.setScalar(CLOCK_SCALE);
scene.add(clockGroup);

// Dial face
let dialMesh;
let dialLowerMesh;
const DIAL_THICKNESS = 0.5; // thin disc — no more cutout walls clipping hands
const DIAL_GAP = 0.5; // minimal gap — thin disc means no visible cutout walls
let cutoutR = R*0.38;
function buildDial() {
  if(dialMesh) clockGroup.remove(dialMesh);
  if(dialLowerMesh) clockGroup.remove(dialLowerMesh);
  
  const subY = -R*0.5;
  cutoutR = R*0.38;
  
  // Lower disc — solid, darker, recessed
  const lowerGeo = new THREE.CylinderGeometry(caseR, caseR, DIAL_THICKNESS, 128);
  const lowerColor = new THREE.Color(DIALS[currentDial].bg).multiplyScalar(0.75);
  const lowerMat = new THREE.MeshBasicMaterial({color:lowerColor}); // unlit // recessed dial — barely there
  dialLowerMesh = new THREE.Mesh(lowerGeo, lowerMat);
  dialLowerMesh.rotation.x = Math.PI/2;
  dialLowerMesh.position.z = -(DIAL_THICKNESS/2 + DIAL_GAP + DIAL_THICKNESS);
  dialLowerMesh.receiveShadow = true;
  clockGroup.add(dialLowerMesh);
  
  // Upper disc — flat circle with subdial cutout
  const dialShape = new THREE.Shape();
  dialShape.absarc(0, 0, caseR, 0, Math.PI*2, false);
  // Cut hole for subdial
  const holePath = new THREE.Path();
  holePath.absarc(0, subY, cutoutR, 0, Math.PI*2, true);
  dialShape.holes.push(holePath);
  const geo = new THREE.ShapeGeometry(dialShape, 128);
  dialMesh = new THREE.Mesh(geo, dialMat(DIALS[currentDial].bg));
  dialMesh.position.z = 0; // flat at origin
  clockGroup.add(dialMesh);
}

// Case ring removed — using dial circle edge only
const caseR = R * 1.12;

// Hour markers (extruded pills — actual 3D)
let markerMeshes = [], lumeMeshes = [];
function buildMarkers() {
  markerMeshes.forEach(m=>clockGroup.remove(m));
  lumeMeshes.forEach(m=>clockGroup.remove(m));
  markerMeshes=[]; lumeMeshes=[];
  
  const c = DIALS[currentDial];
  const isKawthar = currentDial === 'kawthar';
  const isRainbow = currentDial === 'rainbow';
  
  for(let i=0;i<60;i++){
    const ang = Math.PI/2 - (i/60)*Math.PI*2; // CW from 12
    const isHour = i%5===0;
    const hourIdx = i/5;
    // Skip 6 o'clock (qibla cutout) for hour markers
    const isNumeralPos = isHour && [0,2,4,6,8,10].includes(hourIdx);
    
    if(isKawthar) {
      // ── KAWTHAR: playful — chunky pastel circles, each hour its own color ──
      if(isHour && hourIdx !== 6) {
        const dotR = (hourIdx === 0) ? R*0.065 : R*0.05;
        const depth = 3;
        // Chunky rose gold candy buttons
        const geo = new THREE.CylinderGeometry(dotR, dotR, depth, 32);
        const mat = new THREE.MeshPhysicalMaterial({
          color: c.hand, roughness: 0.1, metalness: 0.8,
          clearcoat: 0.8, clearcoatRoughness: 0.1,
          emissive: c.hand, emissiveIntensity: 0
        });
        const mesh = new THREE.Mesh(geo, mat);
        const midR = R * 0.85;
        mesh.position.x = Math.cos(ang)*midR;
        mesh.position.y = Math.sin(ang)*midR;
        mesh.position.z = depth/2;
        mesh.rotation.x = Math.PI/2;
        clockGroup.add(mesh); markerMeshes.push(mesh);
        mesh.userData.kawtharButton = true;
        lumeMeshes.push(mesh); // they all glow at night
      } else if(!isHour) {
        // Simple small dots — rose gold
        const geo = new THREE.CircleGeometry(0.6, 10);
        const mat = new THREE.MeshStandardMaterial({
          color: c.lume, roughness: 0.12, metalness: 0.5,
          emissive: c.lume, emissiveIntensity: 0
        }); mat.envMapIntensity = 3.0; // applied markers — polished metal, visible tilt response
        const mesh = new THREE.Mesh(geo, mat);
        const midR = R * 0.95;
        mesh.position.x = Math.cos(ang)*midR;
        mesh.position.y = Math.sin(ang)*midR;
        mesh.position.z = 1.5;
        clockGroup.add(mesh); markerMeshes.push(mesh);
      }
    } else if(isRainbow) {
      // ── RAINBOW: sorbet gem minute markers — every minute gets a pastel gem ──
      const hue = (i/60);
      const gemColor = new THREE.Color().setHSL(hue, 0.55, 0.72); // sorbet: lower sat, higher lightness
      const isH = isHour && (i/5) !== 6;
      const bW = isH ? R*0.04 : R*0.025;
      const bH = isH ? R*0.09 : R*0.04;
      const depth = isH ? 3 : 2;
      const geo = new THREE.BoxGeometry(bW, bH, depth);
      const mat = new THREE.MeshPhysicalMaterial({
        color: gemColor, roughness: 0.08, metalness: 0.0,
        clearcoat: 1.0, clearcoatRoughness: 0.03,
        transmission: 0.15, thickness: 1.5, ior: 1.77,
        emissive: gemColor, emissiveIntensity: 0.1
      });
      const mesh = new THREE.Mesh(geo, mat);
      const midR = isH ? R*0.87 : R*0.93;
      mesh.position.x = Math.cos(ang)*midR;
      mesh.position.y = Math.sin(ang)*midR;
      mesh.position.z = depth/2;
      mesh.rotation.z = ang + Math.PI/2;
      clockGroup.add(mesh); markerMeshes.push(mesh);
      lumeMeshes.push(mesh);
    } else {
      // ── STANDARD: tick marks + rectangular hour markers ──
      // Always draw a minute tick
      {
        const tH=R*0.036, tW=0.675, depth=1.5;
        const geo = new THREE.BoxGeometry(tW, tH, depth);
        const mat = new THREE.MeshStandardMaterial({color:c.lume, roughness:0.15, metalness:0.4}); mat.envMapIntensity = 2.5; // tick marks — polished, catch light
        const mesh = new THREE.Mesh(geo, mat);
        const midR = (R - R*0.04 - tH/2) * 1.03;
        mesh.position.x = Math.cos(ang)*midR;
        mesh.position.y = Math.sin(ang)*midR;
        mesh.position.z = 2;
        mesh.rotation.z = ang + Math.PI/2;
        clockGroup.add(mesh);
        markerMeshes.push(mesh);
      }
      // Also draw hour marker at non-numeral hour positions
      if(isHour && !isNumeralPos){
        const mH=R*0.12, mW=R*0.05, depth=3;
        const geo = new THREE.BoxGeometry(mW, mH, depth);
        const mesh = new THREE.Mesh(geo, metalMat(c.hand));
        mesh.castShadow = true;
        const midR = (R - R*0.04 - mH/2) * 0.9;
        mesh.position.x = Math.cos(ang)*midR;
        mesh.position.y = Math.sin(ang)*midR;
        mesh.position.z = depth/2;
        mesh.rotation.z = ang + Math.PI/2;
        clockGroup.add(mesh);
        markerMeshes.push(mesh);
        
        // Lume insert
        const lGeo = new THREE.BoxGeometry(mW*0.5, mH*0.65, depth+0.5);
        const lMesh = new THREE.Mesh(lGeo, lumeMat(c.lume));
        lMesh.position.copy(mesh.position);
        lMesh.position.z = depth/2 + 0.3;
        lMesh.rotation.z = mesh.rotation.z;
        clockGroup.add(lMesh);
        lumeMeshes.push(lMesh);
      }
    }
  }
}

// Arabic numerals — extruded 3D geometry (real depth, NOMOS-quality applied)
let numeralSprites = [];
let numeralMats = [];
const NUMERAL_KEY_MAP = {0:'twelve', 2:'two', 4:'four', 8:'eight', 10:'ten'};
const EXTRUDE_DEPTH = 3; // depth of extruded numerals — matches hand height

function buildNumerals() {
  numeralSprites.forEach(s=>clockGroup.remove(s));
  numeralSprites=[]; numeralMats=[];
  if(currentDial === 'kawthar' || currentDial === 'rainbow') return; // special marker dials — no numerals
  const c = DIALS[currentDial];
  const NUMERAL_POS = [0,2,4,8,10]; // 12, 2, 4, 8, 10 (no 6 — qibla)
  const targetH = R * 0.19; // target numeral height on dial — NOMOS proportion
  
  for(const i of NUMERAL_POS){
    const key = NUMERAL_KEY_MAP[i];
    const pd = NUMERAL_PATHS[key];
    if (!pd) continue;
    
    const ang = Math.PI/2 - (i/12)*Math.PI*2; // CW from 12
    const r = R - R*0.18; // numeral ring radius
    const scale = targetH / pd.h; // scale glyph to target height
    
    const shapes = pathToShapes(pd, scale);
    if (!shapes.length) continue;
    
    const extrudeSettings = {
      depth: EXTRUDE_DEPTH,
      bevelEnabled: true,
      bevelThickness: 0.15,
      bevelSize: 0.1,
      bevelOffset: 0,
      bevelSegments: 3,
    };
    
    const geo = new THREE.ExtrudeGeometry(shapes, extrudeSettings);
    geo.computeVertexNormals();
    
    const faceMat = new THREE.MeshPhysicalMaterial({
      color: new THREE.Color(c.lume),
      metalness: 0.6,
      roughness: 0.08,
      clearcoat: 0.5,
      clearcoatRoughness: 0.1,
      envMapIntensity: 4.0,
      emissive: new THREE.Color(c.lume),
      emissiveIntensity: 0, // lume activates in night mode
    });
    
    const mesh = new THREE.Mesh(geo, faceMat);
    mesh.position.x = Math.cos(ang) * r;
    mesh.position.y = Math.sin(ang) * r;
    mesh.position.z = 3.5; // proud of dial — same height as hand base
    clockGroup.add(mesh);
    numeralSprites.push(mesh);
    numeralMats.push(faceMat);
  }
}

// Hands (NOMOS Club Campus sword style — real 3D with lume channel)
let hourGroup, minGroup, secGroup;
let hourMat_, minMat_, secMat_, hLumeMat_, mLumeMat_;

function buildHands() {
  if(hourGroup) clockGroup.remove(hourGroup);
  if(minGroup) clockGroup.remove(minGroup);
  if(secGroup) clockGroup.remove(secGroup);
  
  const c = DIALS[currentDial];
  
  // Hour — NOMOS Club Campus sword hand
  hourGroup = new THREE.Group();
  const hL=R*0.75, hW=R*0.05, hT=R*0.05, hD=4;
  const hGeo = nomosHand(hL, hW, hT, hD);
  hourMat_ = metalMat(c.hand);
  const hMesh = new THREE.Mesh(hGeo, hourMat_);
  hMesh.castShadow = true;
  hourGroup.add(hMesh);
  // Lume channel recessed into hand
  const hlGeo = nomosLume(hL, hW, hD);
  hLumeMat_ = lumeMat(c.lume);
  const hlMesh = new THREE.Mesh(hlGeo, hLumeMat_);
  hlMesh.position.z = 3.5;
  hourGroup.add(hlMesh);
  hourGroup.position.z = 15;
  clockGroup.add(hourGroup);
  
  // Minute — NOMOS Club Campus sword hand
  minGroup = new THREE.Group();
  const mL=R*0.925, mW=R*0.05, mT=R*0.07, mD=5;
  const mGeo = nomosHand(mL, mW, mT, mD);
  minMat_ = metalMat(c.hand);
  const mMesh = new THREE.Mesh(mGeo, minMat_);
  mMesh.castShadow = true;
  minGroup.add(mMesh);
  const mlGeo = nomosLume(mL, mW, mD);
  mLumeMat_ = lumeMat(c.lume);
  const mlMesh = new THREE.Mesh(mlGeo, mLumeMat_);
  mlMesh.position.z = 4.5;
  minGroup.add(mlMesh);
  minGroup.position.z = 17;
  clockGroup.add(minGroup);
  
  // Second hand
  secGroup = new THREE.Group();
  const sL=R*0.96, sT=R*0.16, sD=2;
  const ss = new THREE.Shape();
  ss.moveTo(-0.5,-sT); ss.lineTo(-0.25,sL); ss.lineTo(0.25,sL); ss.lineTo(0.5,-sT); ss.closePath();
  const sGeo = new THREE.ExtrudeGeometry(ss,{depth:sD,bevelEnabled:true,bevelThickness:0.2,bevelSize:0.15,bevelSegments:1});
  secMat_ = secMat(c.sec);
  const sMesh = new THREE.Mesh(sGeo, secMat_);
  sMesh.castShadow = true;
  secGroup.add(sMesh);
  // Counterweight
  const cwGeo = new THREE.CylinderGeometry(R*0.015, R*0.015, sD+1, 16);
  const cwMesh = new THREE.Mesh(cwGeo, secMat_);
  cwMesh.rotation.x = Math.PI/2;
  cwMesh.position.y = -sT*0.55;
  secGroup.add(cwMesh);
  secGroup.position.z = 23;  // must clear minute hand (z=17 + depth 5 = z=22)
  clockGroup.add(secGroup);
  
  // Center cap (3D cylinder) — must sit ON TOP of all hands including second hand
  const capGeo = new THREE.CylinderGeometry(R*0.04, R*0.04, 8, 32);
  const capMesh = new THREE.Mesh(capGeo, metalMat(c.hand));
  capMesh.rotation.x = Math.PI/2;
  capMesh.position.z = 26;  // above second hand (z=23 + depth 2 = z=25)
  capMesh.castShadow = true;
  clockGroup.add(capMesh);
  markerMeshes.push(capMesh); // for cleanup
}

// ══════════════════════════════════════════
// QIBLA ORBITAL COMPASS — Ressence-inspired
// ══════════════════════════════════════════
let qiblaGroup, qiblaRotor, qiblaInnerRotor;
let hasCompassData = false;
let compassHeading = 0, targetCompassHeading = 0;
let qiblaBearing = 0; // degrees from north
let qiblaAligned = false; // hysteresis state
let userLat = null, userLng = null;

// Kaaba coordinates
const KAABA_LAT = 21.4225, KAABA_LNG = 39.8262;

function calcQiblaBearing(lat, lng) {
  const φ1 = lat * Math.PI/180, φ2 = KAABA_LAT * Math.PI/180;
  const Δλ = (KAABA_LNG - lng) * Math.PI/180;
  const x = Math.sin(Δλ) * Math.cos(φ2);
  const y = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
  return ((Math.atan2(x, y) * 180/Math.PI) + 360) % 360;
}

function initQiblaLocation() {
  if(navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(pos => {
      userLat = pos.coords.latitude;
      userLng = pos.coords.longitude;
      qiblaBearing = calcQiblaBearing(userLat, userLng);
    }, () => {
      // Fallback: LA
      userLat = 34.05; userLng = -118.24;
      qiblaBearing = calcQiblaBearing(userLat, userLng);
    });
  }
}
initQiblaLocation();

function buildQibla() {
  if(qiblaGroup) clockGroup.remove(qiblaGroup);
  qiblaGroup = new THREE.Group();
  qiblaGroup.position.y = -R*0.5;
  qiblaGroup.position.z = 0; // flush with dial — cutout prevents z-fighting
  
  const gaugeR = cutoutR - 1.5;
  const d = DIALS[currentDial];
  
  // Base disc — brushed metallic, subtle contrast from dial
  const baseMat = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(d.bg).multiplyScalar(0.82),
    roughness: 0.35, metalness: 0.5,
    clearcoat: 0.4, envMapIntensity: 3.5,
    roughnessMap: metalGrainTex,
  });
  const baseDisc = new THREE.Mesh(new THREE.CircleGeometry(gaugeR, 64), baseMat);
  qiblaGroup.add(baseDisc);
  
  // ── Moon phase (Hijri calendar) ──
  // Ramadan 2026: Feb 17 – Mar 18 (approx)
  const RAMADAN_START = new Date(2026, 1, 17); // Feb 17
  const RAMADAN_DAYS = 30;
  const now = new Date();
  const dayOfRamadan = Math.max(0, Math.min(RAMADAN_DAYS, Math.floor((now - RAMADAN_START) / 86400000) + 1));
  const moonPhase = dayOfRamadan / RAMADAN_DAYS; // 0→1 over the month
  window._hijriMoonPhase = moonPhase;
  
  // Moon disc — bright circle
  const moonR = gaugeR * 0.42;
  const moonMat = new THREE.MeshPhysicalMaterial({
    color: 0xf8f4e8, roughness: 0.6, metalness: 0.05,
    emissive: 0xf8f4e8, emissiveIntensity: 0.05,
    envMapIntensity: 0.1
  });
  const moonDisc = new THREE.Mesh(new THREE.CircleGeometry(moonR, 64), moonMat);
  moonDisc.position.z = 0.1;
  qiblaGroup.add(moonDisc);
  
  // Shadow overlay — creates crescent shape via canvas texture
  const moonCv = document.createElement('canvas');
  moonCv.width = 256; moonCv.height = 256;
  const mCtx = moonCv.getContext('2d');
  const cx = 128, cy = 128, mr = 120;
  
  // Draw shadow side
  mCtx.fillStyle = 'rgba(0,0,0,0)';
  mCtx.clearRect(0, 0, 256, 256);
  
  // Hijri moon: day 1 = thin crescent (right lit), day 15 = full, day 29 = thin crescent (left lit)
  // Phase 0→0.5 = waxing (right to full), 0.5→1 = waning (full to left crescent)
  const p = moonPhase;
  mCtx.save();
  mCtx.beginPath();
  mCtx.arc(cx, cy, mr, 0, Math.PI*2);
  mCtx.clip();
  
  // Dark background (shadow)
  const bgCol = new THREE.Color(d.bg).multiplyScalar(0.5);
  mCtx.fillStyle = `rgb(${bgCol.r*255|0},${bgCol.g*255|0},${bgCol.b*255|0})`;
  mCtx.fillRect(0, 0, 256, 256);
  
  // Lit portion — draw as crescent/gibbous
  // p=0: new moon (dark), p=0.5: full moon, p=1: new moon again
  // Hijri month: day 1 ≈ thin crescent, day 15 ≈ full, day 29 ≈ thin crescent
  mCtx.fillStyle = '#f8f4e8';
  mCtx.beginPath();
  if(p <= 0.5) {
    // Waxing: right side grows from nothing to full
    const illum = p * 2; // 0→1
    // Right semicircle always lit
    mCtx.arc(cx, cy, mr, -Math.PI/2, Math.PI/2);
    // Terminator edge: controls how much of left side is lit/dark
    // illum 0→0.5: concave (crescent), 0.5→1: convex (gibbous)
    const termX = mr * (1 - illum * 2); // mr→-mr as illum 0→1
    mCtx.ellipse(cx, cy, Math.abs(termX), mr, 0, Math.PI/2, -Math.PI/2, illum < 0.5);
  } else {
    // Waning: left side shrinks from full to nothing
    const illum = (1 - p) * 2; // 1→0
    // Left semicircle always lit
    mCtx.arc(cx, cy, mr, Math.PI/2, -Math.PI/2);
    // Terminator
    const termX = mr * (1 - illum * 2);
    mCtx.ellipse(cx, cy, Math.abs(termX), mr, 0, -Math.PI/2, Math.PI/2, illum < 0.5);
  }
  mCtx.fill();
  mCtx.restore();
  
  // Soft edge
  const grad = mCtx.createRadialGradient(cx, cy, mr*0.9, cx, cy, mr);
  grad.addColorStop(0, 'rgba(0,0,0,0)');
  grad.addColorStop(1, 'rgba(0,0,0,1)');
  mCtx.fillStyle = grad;
  mCtx.fillRect(0, 0, 256, 256);
  
  const moonTex = new THREE.CanvasTexture(moonCv);
  const moonOverlay = new THREE.Mesh(
    new THREE.CircleGeometry(moonR, 64),
    new THREE.MeshBasicMaterial({map: moonTex, transparent: true})
  );
  moonOverlay.position.z = 0.15;
  qiblaGroup.add(moonOverlay);
  
  // ── Fasting arc (Fajr → Maghrib daily progress) ──
  if(PD && PD.Fajr && PD.Maghrib) {
    const fajrMin = pM(PD.Fajr);
    const maghribMin = pM(PD.Maghrib);
    const nowMin = now.getHours()*60 + now.getMinutes();
    const fastDuration = maghribMin - fajrMin;
    const fastProgress = Math.max(0, Math.min(1, (nowMin - fajrMin) / fastDuration));
    
    // Fasting progress — placeholder removed, revisiting later
  }
  
  // Outer rotor — the main Ressence-style rotating disc
  qiblaRotor = new THREE.Group();
  qiblaRotor.position.z = 0.5;
  
  // Rotor disc — slightly smaller, different tone
  const rotorR = gaugeR - 2;
  const rotorMat = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(d.bg).multiplyScalar(0.75),
    roughness: 0.2, metalness: 0.6,
    clearcoat: 0.6, envMapIntensity: 3.0,
  });
  const rotorDisc = new THREE.Mesh(new THREE.CircleGeometry(rotorR, 64), rotorMat);
  qiblaRotor.add(rotorDisc);
  
  // Cardinal tick marks on rotor rim (N, E, S, W as subtle lines)
  const tickLen = gaugeR * 0.12;
  const tickW = 0.4;
  for(let i = 0; i < 4; i++) {
    const ang = (i/4) * Math.PI * 2; // 0=N(up), π/2=E, π=S, 3π/2=W
    const isNorth = i === 0;
    const tGeo = new THREE.BoxGeometry(tickW, isNorth ? tickLen*1.4 : tickLen, 0.3);
    const tColor = isNorth ? 0xf0f0f0 : new THREE.Color(d.lume).multiplyScalar(0.8);
    const tMat = new THREE.MeshPhysicalMaterial({
      color: tColor, roughness: 0.2, metalness: 0.3, envMapIntensity: 1.5
    });
    const tick = new THREE.Mesh(tGeo, tMat);
    const tr = rotorR - tickLen*0.55;
    tick.position.set(Math.sin(ang)*tr, Math.cos(ang)*tr, 0.2);
    tick.rotation.z = -ang;
    qiblaRotor.add(tick);
  }
  
  // 8 minor ticks (every 45°, skip cardinals)
  for(let i = 0; i < 8; i++) {
    if(i % 2 === 0) continue; // skip cardinals
    const ang = (i/8) * Math.PI * 2;
    const mtGeo = new THREE.BoxGeometry(0.3, tickLen*0.5, 0.2);
    const mtMat = new THREE.MeshPhysicalMaterial({
      color: new THREE.Color(d.lume).multiplyScalar(0.5),
      roughness: 0.3, metalness: 0.2, envMapIntensity: 1.0,
    });
    const mt = new THREE.Mesh(mtGeo, mtMat);
    const mtr = rotorR - tickLen*0.3;
    mt.position.set(Math.sin(ang)*mtr, Math.cos(ang)*mtr, 0.2);
    mt.rotation.z = -ang;
    qiblaRotor.add(mt);
  }
  
  qiblaGroup.add(qiblaRotor);
  
  // ── Concentric rotating rings ──
  const ringDefs = [
    { r: rotorR * 0.85, width: 1.8, speed: 0.3,  dir: 1  },  // outer ring — slow CW
    { r: rotorR * 0.65, width: 1.2, speed: 0.5,  dir: -1 },  // mid ring — medium CCW
    { r: rotorR * 0.48, width: 1.0, speed: 0.8,  dir: 1  },  // inner ring — faster CW
  ];
  
  // Dial palette — our own watch face colors as segments
  const sorbet = [
    0x68b890, // tennis
    0xd8988c, // salmon
    0x82b8d8, // sky
    0xf2dce0, // kawthar
    0xf08040, // dhuha
    0x384870, // najm
    0xd89098, // ward
    0x8878a8, // lilas
  ];
  const segCount = 8;
  
  window._subdialRings = [];
  ringDefs.forEach((rd, ri) => {
    const ringGroup = new THREE.Group();
    const gap = 0.03; // radians gap between segments
    
    for(let s = 0; s < segCount; s++) {
      const startAng = (s / segCount) * Math.PI * 2 + gap;
      const endAng = ((s + 1) / segCount) * Math.PI * 2 - gap;
      
      const segShape = new THREE.Shape();
      segShape.absarc(0, 0, rd.r, startAng, endAng, false);
      segShape.absarc(0, 0, rd.r - rd.width, endAng, startAng, true);
      segShape.closePath();
      
      // Offset color index per ring so alignment creates columns
      const colIdx = (s + ri * 0) % segCount; // same order — alignment = color match
      const fullColor = new THREE.Color(sorbet[colIdx]);
      const dimColor = fullColor.clone(); // full color — the Ressence rings should pop
      const segMat = new THREE.MeshPhysicalMaterial({
        color: fullColor,
        roughness: 0.3, metalness: 0.1,
        clearcoat: 1.0, envMapIntensity: 2.0,
        emissive: fullColor, emissiveIntensity: 0.45,
      });
      segMat.userData = { fullColor, dimColor };
      const segMesh = new THREE.Mesh(new THREE.ShapeGeometry(segShape), segMat);
      segMesh.position.z = 0.15;
      ringGroup.add(segMesh);
    }
    
    ringGroup.position.z = 0.3;
    qiblaRotor.add(ringGroup);
    window._subdialRings.push({ group: ringGroup, speed: rd.speed, dir: rd.dir });
  });
  
  // Inner rotor — smaller orbiting disc (Ressence double-orbit)
  qiblaInnerRotor = new THREE.Group();
  qiblaInnerRotor.position.z = 1;
  
  const innerR = gaugeR * 0.28;
  const innerMat = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(d.bg).multiplyScalar(0.65),
    roughness: 0.08, metalness: 0.8,
    clearcoat: 0.8, envMapIntensity: 4.0,
  });
  const innerDisc = new THREE.Mesh(new THREE.CircleGeometry(innerR, 48), innerMat);
  qiblaInnerRotor.add(innerDisc);
  
  // Qibla marker — small triangle on inner disc pointing to Mecca
  const triH = innerR * 1.56;
  const triW = innerR * 1.04;
  const triShape = new THREE.Shape();
  triShape.moveTo(0, triH/2);
  triShape.lineTo(-triW/2, -triH/2);
  triShape.lineTo(triW/2, -triH/2);
  triShape.closePath();
  const triGeo = new THREE.ExtrudeGeometry(triShape, {depth:0.5, bevelEnabled:false});
  const triMat = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(d.hand),
    roughness: 0.2, metalness: 0.3,
    emissive: new THREE.Color(d.hand), emissiveIntensity: 0.15,
    envMapIntensity: 1.5,
  });
  const triMesh = new THREE.Mesh(triGeo, triMat);
  triMesh.position.set(0, innerR*0.35, 0.3);
  qiblaInnerRotor.add(triMesh);
  window._qiblaTriMat = triMat;
  
  // Position inner rotor offset from center (orbiting)
  qiblaInnerRotor.position.y = gaugeR * 0.38;
  qiblaRotor.add(qiblaInnerRotor);
  
  clockGroup.add(qiblaGroup);
  
  // ── Glass sapphire crystal dome over subdial ──
  // Research: real sapphire crystal = IOR 1.77, very low roughness,
  // slight dispersion for chromatic aberration at edges,
  // transmission ~0.98 (nearly perfectly clear).
  // Key insight: don't use opacity — use transmission only.
  // opacity + transmission = muddy. transmission alone = physically correct.
  const glassR = cutoutR - 0.5;
  const glassDome = new THREE.SphereGeometry(
    glassR, 64, 32,
    0, Math.PI*2,
    0, Math.PI*0.12   // subtle dome (~22° cap) — watch crystal, not fishbowl
  );
  // ── Liquid Glass effect ──
  // Two-layer approach: transmission for devices that support it,
  // graceful fallback via low opacity + high env reflections.
  // Based on ektogamat/apple-liquid-glass (MIT) recipe.
  const glassMat = new THREE.MeshPhysicalMaterial({
    color: 0xffffff,
    roughness: 0.12,
    metalness: 0.0,
    transmission: 0.95,    // near-full transmission
    thickness: 1.5,        // subtle refraction — don't obliterate subdial readability
    ior: 1.5,              // standard glass — more predictable across devices than 1.8
    dispersion: 3,         // moderate chromatic shimmer (not as aggressive as ektogamat's 12)
    clearcoat: 1.0,
    clearcoatRoughness: 0.05,
    transparent: true,     // fallback: if transmission fails, opacity kicks in
    opacity: 0.15,         // very subtle — only visible if transmission doesn't work
    iridescence: 0.6,      // partial thin-film — subtle rainbow, not overpowering
    iridescenceIOR: 1.3,
    iridescenceThicknessRange: [200, 400],
    envMapIntensity: 3.0,
    specularIntensity: 1.5,
    specularColor: new THREE.Color(0xffffff),
  });
  const glassMesh = new THREE.Mesh(glassDome, glassMat);
  glassMesh.position.y = -R*0.5;
  glassMesh.position.z = 2;
  glassMesh.rotation.x = 0;
  glassMesh.renderOrder = 10;
  glassMesh.material.depthWrite = false;
  glassMesh.visible = true;
  clockGroup.add(glassMesh);
  bezelMeshes.push(glassMesh);
}

// Rebuild subdial every 60s to update fasting arc
let lastSubdialRebuild = 0;
function updateQibla() {
  if(!qiblaRotor) return;
  const now = Date.now();
  if(now - lastSubdialRebuild > 60000) { lastSubdialRebuild = now; buildQibla(); }
  // No compass → everything at rest on the 12-6 centerline
  if(!hasCompassData) {
    qiblaRotor.rotation.z += (0 - qiblaRotor.rotation.z) * 0.12;
    qiblaInnerRotor.rotation.z += (0 - qiblaInnerRotor.rotation.z) * 0.12;
    return;
  }
  
  // Smooth compass heading
  compassHeading += ((targetCompassHeading - compassHeading + 540) % 360 - 180) * 0.6;
  
  // Check alignment — hysteresis to prevent jitter (enter at 15°, exit at 25°)
  const qiblaOffset = ((qiblaBearing - compassHeading) % 360 + 360) % 360;
  const offDeg = Math.min(qiblaOffset, 360 - qiblaOffset);
  if(offDeg < 15) qiblaAligned = true;
  if(offDeg > 25) qiblaAligned = false;
  const aligned = qiblaAligned;
  
  // Outer rotor: compass direction — but eases to 0 when aligned so inner rotor
  // sits on the 12-6 centerline (triangle tip → 12, base → 6)
  const compassRad = -(compassHeading * Math.PI/180);
  const targetOuterRot = aligned ? 0 : compassRad;
  const snapSpeed = aligned ? 0.3 : 0.5;
  qiblaRotor.rotation.z += (targetOuterRot - qiblaRotor.rotation.z) * snapSpeed;
  
  // Inner rotor: triangle points toward Qibla relative to user
  // When aligned + outer eased to 0: inner rotation = 0 → triangle at exact 12
  const desiredWorld = aligned ? 0 : -(qiblaBearing - compassHeading) * Math.PI / 180;
  const targetInnerRot = desiredWorld - qiblaRotor.rotation.z;
  qiblaInnerRotor.rotation.z += (targetInnerRot - qiblaInnerRotor.rotation.z) * snapSpeed;
}

// Split-flap at 12 o'clock
let flapSprite, flapCanvas, flapTexture;
let flapPrevChars=[], flapCharAnims=[];
const FLAP_DUR=350, FLAP_STAGGER=60;

function buildFlap() {
  if(flapSprite) clockGroup.remove(flapSprite);
  const cw=1024, ch=384;
  flapCanvas=document.createElement('canvas');
  flapCanvas.width=cw; flapCanvas.height=ch;
  flapTexture=new THREE.CanvasTexture(flapCanvas);
  flapTexture.minFilter=THREE.LinearFilter;
  const geo=new THREE.PlaneGeometry(R*0.55, R*0.2);
  flapSprite=new THREE.Mesh(geo, new THREE.MeshBasicMaterial({map:flapTexture,transparent:true,depthTest:false}));
  flapSprite.position.y=R*0.32;
  flapSprite.position.z=5;
  flapSprite.visible = false;
  clockGroup.add(flapSprite);
}

// Stars (Surah Yusuf 12:4) — 11 stars in a sujud (prostration) arc above the clock
// "I saw eleven stars and the sun and the moon — I saw them prostrating to me."
const STARS=[];
{
  // Arc from left to right above the clock, bowing downward (sujud toward the dial)
  const arcCenterY = R * 0.95;  // raised — outer stars near viewport edge
  const arcRadius = R * 0.7;    // wide spread
  const arcDepth = R * 0.12;    // concave bow — lowest point clears dial face
  for(let i = 0; i < 11; i++) {
    const t = i / 10; // 0 to 1
    const ang = Math.PI * 0.15 + t * Math.PI * 0.7; // ~27° to ~153° — spread across top
    const x = -Math.cos(ang) * arcRadius;
    const y = arcCenterY - Math.sin(ang) * arcDepth; // concave: middle stars bow DOWN toward dial
    const size = 0.55 + Math.sin(i * 1.7 + 0.5) * 0.2; // tiny twinkling points
    STARS.push({
      px: x, py: y,
      r: size,
      speed: 0.0008 + i * 0.00006,
      offset: i * 0.57,
      bright: 0.75 + Math.sin(i * 2.3) * 0.2
    });
  }
}
let starMeshes=[];
let moonGroup, moonMesh, moonGlowMesh;

function buildStars(){
  starMeshes.forEach(m=>scene.remove(m)); starMeshes=[];
  STARS.forEach(s=>{
    const m=new THREE.Mesh(new THREE.CircleGeometry(s.r, 16), new THREE.MeshBasicMaterial({color:0xfffff0, transparent:true, opacity:0}));
    m.position.x = s.px;
    m.position.y = s.py;
    m.position.z = -10; m.userData=s; scene.add(m); starMeshes.push(m);
  });
  
  // 3D Moon — rises during night transition
  if(moonGroup) scene.remove(moonGroup);
  moonGroup = new THREE.Group();
  
  const moonR = 10;
  
  // ── Procedural moon texture with craters + Hijri phase shadow ──
  const moonCvN = document.createElement('canvas');
  moonCvN.width = 256; moonCvN.height = 256;
  const mxN = moonCvN.getContext('2d');
  const mcx = 128, mcy = 128, mcr = 124;
  
  // Clip everything to circle — no debris outside the moon disc
  mxN.save();
  mxN.beginPath(); mxN.arc(mcx, mcy, mcr, 0, Math.PI*2); mxN.clip();
  
  // Base moon color — warm lunar grey
  mxN.fillStyle = '#e8e4d8';
  mxN.fillRect(0, 0, 256, 256);
  
  // Subtle surface variation (maria/highlands)
  const surfGrad = mxN.createRadialGradient(100, 90, 10, mcx, mcy, mcr);
  surfGrad.addColorStop(0, 'rgba(180,175,160,0.3)');
  surfGrad.addColorStop(0.5, 'rgba(200,195,180,0.15)');
  surfGrad.addColorStop(1, 'rgba(220,215,200,0)');
  mxN.fillStyle = surfGrad;
  mxN.beginPath(); mxN.arc(mcx, mcy, mcr, 0, Math.PI*2); mxN.fill();
  
  // Craters — seeded pseudo-random
  const craters = [
    {x:95, y:80, r:18, d:0.12},   // Tycho-like
    {x:155, y:105, r:22, d:0.10},  // Copernicus-like  
    {x:130, y:155, r:15, d:0.08},
    {x:75, y:135, r:12, d:0.10},
    {x:165, y:65, r:10, d:0.07},
    {x:110, y:60, r:8, d:0.09},
    {x:145, y:180, r:14, d:0.06},
    {x:85, y:170, r:9, d:0.08},
    {x:170, y:145, r:7, d:0.07},
    {x:120, y:120, r:6, d:0.05},
  ];
  craters.forEach(c => {
    // Shadow inside crater
    const cGrad = mxN.createRadialGradient(c.x - c.r*0.2, c.y - c.r*0.2, 0, c.x, c.y, c.r);
    cGrad.addColorStop(0, `rgba(140,135,120,${c.d})`);
    cGrad.addColorStop(0.6, `rgba(160,155,140,${c.d * 0.5})`);
    cGrad.addColorStop(1, 'rgba(200,195,180,0)');
    mxN.fillStyle = cGrad;
    mxN.beginPath(); mxN.arc(c.x, c.y, c.r, 0, Math.PI*2); mxN.fill();
    // Rim highlight
    mxN.strokeStyle = `rgba(245,240,230,${c.d * 0.4})`;
    mxN.lineWidth = 0.8;
    mxN.beginPath(); mxN.arc(c.x, c.y, c.r * 0.9, -0.5, 1.2); mxN.stroke();
  });
  
  // ── Hijri moon phase shadow ──
  // Calculate independently — buildStars may run before buildQibla
  // Synodic month calculation — works year-round, not just Ramadan
  // Known new moon: Jan 29, 2026 12:36 UTC (astronomical)
  const KNOWN_NEW_MOON = new Date(Date.UTC(2026, 0, 29, 12, 36));
  const SYNODIC = 29.53059; // days
  const daysSinceNew = (Date.now() - KNOWN_NEW_MOON.getTime()) / 86400000;
  const phase = ((daysSinceNew % SYNODIC) + SYNODIC) % SYNODIC / SYNODIC; // 0→1
  // Phase rendering — pixel-based for reliability
  // phase 0 = new moon (dark), 0.5 = full moon, 1.0 = dark again
  // illumination: 0→1→0 over the month
  const illum = phase <= 0.5 ? phase * 2 : (1 - phase) * 2; // 0→1→0
  const waxing = phase <= 0.5; // right side lit first (Northern hemisphere Hijri)
  
  // Draw shadow overlay using compositing
  const shadowCv = document.createElement('canvas');
  shadowCv.width = 256; shadowCv.height = 256;
  const sx = shadowCv.getContext('2d');
  
  // Fill with shadow
  sx.fillStyle = 'rgba(5,5,10,0.93)';
  sx.beginPath(); sx.arc(mcx, mcy, mcr + 1, 0, Math.PI * 2); sx.fill();
  
  // Cut out the illuminated portion
  sx.globalCompositeOperation = 'destination-out';
  sx.fillStyle = '#fff';
  sx.beginPath();
  
  if(illum < 0.01) {
    // New moon — all dark, cut nothing
  } else if(illum > 0.99) {
    // Full moon — cut everything
    sx.arc(mcx, mcy, mcr + 1, 0, Math.PI * 2);
    sx.fill();
  } else {
    // Crescent/gibbous — half circle + terminator ellipse
    const litSide = waxing ? 1 : -1; // +1 = right lit, -1 = left lit
    // Always draw the lit half-circle
    const startAng = litSide > 0 ? -Math.PI/2 : Math.PI/2;
    const endAng = litSide > 0 ? Math.PI/2 : -Math.PI/2;
    sx.arc(mcx, mcy, mcr, startAng, endAng);
    // Terminator: ellipse width controls crescent shape
    // illum 0→0.5: crescent (terminator on lit side), 0.5→1: gibbous (terminator on dark side)
    const tWidth = Math.abs(illum * 2 - 1) * mcr;
    const ccw = illum < 0.5; // crescent: cut less, gibbous: cut more
    sx.ellipse(mcx, mcy, tWidth || 0.5, mcr, 0, endAng, startAng, ccw);
    sx.closePath();
    sx.fill();
  }
  
  // Apply shadow to moon
  mxN.drawImage(shadowCv, 0, 0);
  
  // Soft limb darkening — edge of moon sphere
  const limbGrad = mxN.createRadialGradient(mcx, mcy, mcr * 0.7, mcx, mcy, mcr);
  limbGrad.addColorStop(0, 'rgba(0,0,0,0)');
  limbGrad.addColorStop(1, 'rgba(0,0,0,0.2)');
  mxN.fillStyle = limbGrad;
  mxN.beginPath(); mxN.arc(mcx, mcy, mcr, 0, Math.PI*2); mxN.fill();
  mxN.restore(); // release global moon clip
  
  const moonTexN = new THREE.CanvasTexture(moonCvN);
  
  // Moon mesh with texture
  const moonGeo = new THREE.CircleGeometry(moonR, 48);
  const moonMat = new THREE.MeshBasicMaterial({
    map: moonTexN,
    color: new THREE.Color(1.15, 1.12, 1.05), // barely HDR — moon glows, doesn't blast
    transparent: true, opacity: 0, depthWrite: false,
  });
  moonMesh = new THREE.Mesh(moonGeo, moonMat);
  moonGroup.add(moonMesh);
  
  // Soft radial glow — larger, subtle
  const glowGeo = new THREE.CircleGeometry(moonR * 2.5, 48);
  // Radial gradient texture for soft atmospheric falloff
  const glowCv = document.createElement('canvas');
  glowCv.width = 128; glowCv.height = 128;
  const gCtx = glowCv.getContext('2d');
  const grad = gCtx.createRadialGradient(64, 64, 0, 64, 64, 64);
  grad.addColorStop(0, 'rgba(255,250,240,1)');
  grad.addColorStop(0.15, 'rgba(255,245,230,0.6)');
  grad.addColorStop(0.4, 'rgba(255,240,220,0.2)');
  grad.addColorStop(0.7, 'rgba(255,235,210,0.05)');
  grad.addColorStop(1, 'rgba(255,230,200,0)');
  gCtx.fillStyle = grad;
  gCtx.fillRect(0, 0, 128, 128);
  const glowTex = new THREE.CanvasTexture(glowCv);
  const glowMat = new THREE.MeshBasicMaterial({
    map: glowTex,
    color: new THREE.Color(1.5, 1.4, 1.2),
    transparent: true, opacity: 0, depthWrite: false,
  });
  moonGlowMesh = new THREE.Mesh(glowGeo, glowMat);
  moonGlowMesh.position.z = -0.5;
  moonGroup.add(moonGlowMesh);
  
  moonGroup.position.set(0, -60, -15);
  moonGroup.visible = false;
  scene.add(moonGroup);
}

// ══════════════════════════════════════════
// BUILD ALL
// ══════════════════════════════════════════
function updateSurah() {
  const el = document.getElementById('surah');
  if(el) {
    const d = DIALS[currentDial];
    el.textContent = d.surah || '';
    el.style.color = d.text || '#ffffff';
  }
  const toggle = document.getElementById('modeToggle');
  if(toggle) toggle.style.color = DIALS[currentDial].text || '#ffffff';
  updateModeIcon();
}
// ══════════════════════════════════════════
// RAINBOW BEZEL — Rolex Daytona Rainbow tribute
// ══════════════════════════════════════════
let bezelMeshes = [];
function buildBezel() {
  bezelMeshes.forEach(m => clockGroup.remove(m));
  bezelMeshes = [];
  if(!DIALS[currentDial].bezel) return;
  
  // 36 sapphires around the bezel — rainbow gradient
  const GEMS = 36;
  const bezelR = caseR + 2;
  const gemSize = R * 0.04;
  
  for(let i = 0; i < GEMS; i++) {
    const ang = Math.PI/2 - (i/GEMS) * Math.PI * 2;
    const hue = (i/GEMS); // 0→1 around the rainbow
    const color = new THREE.Color().setHSL(hue, 0.85, 0.55);
    
    // Gem: small extruded octagon for faceted look
    const shape = new THREE.Shape();
    const sides = 8;
    for(let s = 0; s < sides; s++) {
      const a = (s/sides) * Math.PI * 2;
      const x = Math.cos(a) * gemSize;
      const y = Math.sin(a) * gemSize;
      if(s === 0) shape.moveTo(x, y);
      else shape.lineTo(x, y);
    }
    shape.closePath();
    
    const geo = new THREE.ExtrudeGeometry(shape, {
      depth: 2.5,
      bevelEnabled: true,
      bevelThickness: 0.6,
      bevelSize: 0.4,
      bevelSegments: 3
    });
    
    const mat = new THREE.MeshPhysicalMaterial({
      color: color,
      roughness: 0.05,
      metalness: 0.0,
      clearcoat: 1.0,
      clearcoatRoughness: 0.02,
      reflectivity: 1.0,
      transmission: 0.3,
      thickness: 2,
      ior: 1.77, // sapphire IOR
      emissive: color,
      emissiveIntensity: 0.1
    });
    
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.x = Math.cos(ang) * bezelR;
    mesh.position.y = Math.sin(ang) * bezelR;
    mesh.position.z = 0;
    mesh.rotation.z = ang;
    clockGroup.add(mesh);
    bezelMeshes.push(mesh);
  }
  
  // Gold bezel ring underneath the gems
  const ringGeo = new THREE.TorusGeometry(bezelR, gemSize * 0.8, 16, 128);
  const ringMat = new THREE.MeshPhysicalMaterial({
    color: 0xc8a850,
    roughness: 0.1,
    metalness: 0.9,
    clearcoat: 0.8,
    clearcoatRoughness: 0.05
  });
  const ring = new THREE.Mesh(ringGeo, ringMat);
  ring.position.z = -0.5;
  clockGroup.add(ring);
  bezelMeshes.push(ring);
}

function buildAll(){
  while(clockGroup.children.length) clockGroup.remove(clockGroup.children[0]);
  const dialBg = new THREE.Color(DIALS[currentDial].bg);
  bgPlaneMat.color.copy(dialBg);
  if(!EMBED) scene.background = dialBg.clone();
  document.documentElement.style.background = document.body.style.background = '#' + dialBg.getHexString(); // extend to notch/Dynamic Island
  const steps = [['dial',buildDial],['bezel',buildBezel],['markers',buildMarkers],['numerals',buildNumerals],['hands',buildHands],['qibla',buildQibla],['flap',buildFlap],['stars',buildStars],['surah',updateSurah]];
  for(const [name,fn] of steps) { try { fn(); } catch(e) { console.error(`buildAll: ${name} failed:`, e); } }
}
// Wait for fonts then build (Lateef for Arabic numerals)
document.fonts.ready.then(()=>buildAll());

// ══════════════════════════════════════════
// UPDATES
// ══════════════════════════════════════════
let secAngle=0;

function updateHands(){
  const now=new Date();
  const h=now.getHours()%12, m=now.getMinutes(), s=now.getSeconds(), ms=now.getMilliseconds();
  const sec=s+ms/1000, min=m+sec/60, hour=h+min/60;
  
  if(hourGroup) hourGroup.rotation.z=-(hour/12)*Math.PI*2;
  if(minGroup) minGroup.rotation.z=-(min/60)*Math.PI*2;
  
  // Quartz sweep
  secAngle=-(sec/60)*Math.PI*2;
  if(secGroup) secGroup.rotation.z=secAngle;
}

function updateFlap(){
  if(!flapCanvas)return;
  const ctx=flapCanvas.getContext('2d');
  const cw=flapCanvas.width, ch=flapCanvas.height;
  ctx.clearRect(0,0,cw,ch);
  
  const now=new Date(), nowMin=now.getHours()*60+now.getMinutes()+now.getSeconds()/60;
  let label='',mins=0;
  if(PD){
    const fajr=pM(PD.Fajr),mag=pM(PD.Maghrib),isha=pM(PD.Isha);
    if(nowMin>=fajr&&nowMin<mag){mins=mag-nowMin;label='UNTIL IFTAR';}
    else if(nowMin>=mag&&nowMin<isha){mins=isha-nowMin;label='UNTIL ISHA';}
    else if(nowMin>=isha){mins=(24*60-nowMin)+fajr;label='UNTIL FAJR';}
    else{mins=fajr-nowMin;label='UNTIL FAJR';}
  }
  
  const hh=Math.floor(mins/60),mm=Math.floor(mins%60);
  const chars=[String(Math.floor(hh/10)),String(hh%10),':',String(Math.floor(mm/10)),String(mm%10)];
  const nowMs=performance.now();
  while(flapPrevChars.length<chars.length)flapPrevChars.push('');
  while(flapCharAnims.length<chars.length)flapCharAnims.push({start:0,prev:''});
  for(let i=0;i<chars.length;i++){if(chars[i]!==flapPrevChars[i])flapCharAnims[i]={start:nowMs+i*FLAP_STAGGER,prev:flapPrevChars[i]||chars[i]};}
  flapPrevChars=chars.slice();
  
  const c=DIALS[currentDial];
  const digitW=cw*0.17,colonW=cw*0.06,cellH=ch*0.65;
  const charWidths=chars.map(c=>c===':'?colonW:digitW);
  const totalW=charWidths.reduce((a,w)=>a+w,0)+(chars.length-1)*4;
  let curX=(cw-totalW)/2;
  const cellY=ch*0.15,fontSize=cellH*0.7;
  const lumeCol=c.text;
  
  for(let i=0;i<chars.length;i++){
    const ch2=chars[i],charW=charWidths[i],cellCx=curX+charW/2;
    if(ch2===':'){
      ctx.fillStyle=lumeCol;ctx.globalAlpha=0.4;
      ctx.beginPath();ctx.arc(cellCx,cellY+cellH*0.3,4,0,Math.PI*2);ctx.fill();
      ctx.beginPath();ctx.arc(cellCx,cellY+cellH*0.7,4,0,Math.PI*2);ctx.fill();
      ctx.globalAlpha=1;curX+=charW+4;continue;
    }
    ctx.fillStyle='rgba(0,0,0,0.3)';rr(ctx,curX,cellY,charW,cellH,6);ctx.fill();
    ctx.fillStyle='rgba(0,0,0,0.4)';ctx.fillRect(curX,cellY+cellH/2-0.5,charW,1);
    ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.font=`500 ${fontSize}px Inter,system-ui`;
    ctx.fillStyle=lumeCol;ctx.globalAlpha=0.9;
    ctx.fillText(ch2,cellCx,cellY+cellH/2);
    ctx.globalAlpha=1;curX+=charW+4;
  }
  if(label){
    ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.font=`500 ${ch*0.1}px Inter,system-ui`;
    ctx.fillStyle=lumeCol;ctx.globalAlpha=0.55;
    ctx.fillText(label,cw/2,cellY+cellH+ch*0.14);
    ctx.globalAlpha=1;
  }
  flapTexture.needsUpdate=true;
}
function rr(ctx,x,y,w,h,r){ctx.beginPath();ctx.moveTo(x+r,y);ctx.lineTo(x+w-r,y);ctx.quadraticCurveTo(x+w,y,x+w,y+r);ctx.lineTo(x+w,y+h-r);ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);ctx.lineTo(x+r,y+h);ctx.quadraticCurveTo(x,y+h,x,y+h-r);ctx.lineTo(x,y+r);ctx.quadraticCurveTo(x,y,x+r,y);ctx.closePath();}

// ══════════════════════════════════════════
// PRAYER TIMES
// ══════════════════════════════════════════
async function fetchPrayer(){
  try{
  // Use date-based endpoint with auto-detected location
  const d=new Date(), dd=`${d.getDate()}-${d.getMonth()+1}-${d.getFullYear()}`;
  const r=await fetch(`https://api.aladhan.com/v1/timingsByCity/${dd}?city=LosAngeles&country=US&method=2`);
  const j=await r.json();if(j.code===200){PD=j.data.timings;
  document.getElementById('hijri').textContent=`Fajr ${PD.Fajr} · Maghrib ${PD.Maghrib}`;
  document.getElementById('hijri').style.color=DIALS[currentDial].text;
  document.getElementById('greg').textContent=new Date().toLocaleDateString('en-US',{weekday:'long',year:'numeric',month:'long',day:'numeric'});
  document.getElementById('greg').style.color=DIALS[currentDial].text;
  }}catch(e){}
}
fetchPrayer();

// ══════════════════════════════════════════
// INTERACTIONS
// ══════════════════════════════════════════
let infoTimer;
const SUN_SVG='<circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>';
const MOON_SVG='<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>';
function updateModeIcon(){
  const icon=document.getElementById('modeIcon');
  if(icon) icon.innerHTML=modeTarget>0.5?SUN_SVG:MOON_SVG;
}
document.getElementById('modeToggle').addEventListener('click',(e)=>{
  e.stopPropagation();
  modeTarget=modeTarget>0.5?0:1;
  updateModeIcon();
});
function showInfo(){
  document.getElementById('info').classList.add('visible');
  document.getElementById('dialBar').classList.add('visible');
  document.getElementById('modeToggle').classList.add('visible');
  clearTimeout(infoTimer);
  infoTimer=setTimeout(()=>{document.getElementById('info').classList.remove('visible');document.getElementById('dialBar').classList.remove('visible');document.getElementById('modeToggle').classList.remove('visible');},4000);
}
renderer.domElement.addEventListener('click',showInfo);
renderer.domElement.addEventListener('dblclick',()=>{modeTarget=modeTarget>0.5?0:1;});

let touchStartX=0, touchStartY=0;
renderer.domElement.addEventListener('touchstart',e=>{
  touchStartX=e.touches[0].clientX;
  touchStartY=e.touches[0].clientY;
},{passive:true});
renderer.domElement.addEventListener('touchend',e=>{
  const dx=e.changedTouches[0].clientX-touchStartX;
  const dy=e.changedTouches[0].clientY-touchStartY;
  // Determine if swipe is more horizontal or vertical
  if(Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > 50) {
    // Vertical swipe — up = night, down = day
    modeTarget = dy < 0 ? 1 : 0;
  } else if(Math.abs(dx) > 50) {
    // Horizontal swipe — change dial
    const idx=DIAL_NAMES.indexOf(currentDial);
    currentDial=DIAL_NAMES[dx>0?(idx-1+DIAL_NAMES.length)%DIAL_NAMES.length:(idx+1)%DIAL_NAMES.length];
    buildAll();
  }
});
document.querySelectorAll('.dial-dot').forEach(d=>{d.addEventListener('click',e=>{e.stopPropagation();currentDial=d.dataset.dial;buildAll();document.querySelectorAll('.dial-dot').forEach(x=>x.classList.toggle('active',x.dataset.dial===currentDial));});});

// ══════════════════════════════════════════
// RESIZE
// ══════════════════════════════════════════
// Listen for dispose message from parent (landing page iframe management)
window.addEventListener('message',(e)=>{
  if(e.data&&e.data.type==='dispose'){
    renderer.dispose();renderer.forceContextLoss();
  }
  if(e.data&&e.data.type==='switchDial'&&DIALS[e.data.dial]){
    currentDial=e.data.dial;
    buildAll();
  }
  if(e.data&&e.data.type==='nightOn'){modeTarget=1;}
  if(e.data&&e.data.type==='nightOff'){modeTarget=0;}
});
window.addEventListener('resize',()=>{
  W=window.innerWidth;H=window.innerHeight;
  renderer.setSize(W,H);
  const a=W/H;
  cam.aspect=a;
  cam.position.z = 280;
  cam.updateProjectionMatrix();
  composer.setSize(W, H);
  bloomPass.resolution.set(W, H);
});

// ══════════════════════════════════════════
// RENDER LOOP
// ══════════════════════════════════════════
const vignetteEl = document.getElementById('vignette');
function animate(){
  requestAnimationFrame(animate);
  
  // Night blend
  if(Math.abs(modeBlend-modeTarget)>0.001) modeBlend+=(modeTarget-modeBlend)*0.015;
  else modeBlend=modeTarget;
  
  // Night mode: lume glow with per-dial color
  const nightLume = NIGHT_LUME[currentDial] || NIGHT_LUME.slate;
  const lumeEmCol = new THREE.Color(nightLume.emissive);
  // Subtle lume breathing — very slow, barely perceptible (±5%)
  const lumeBreathe = 1.0 + Math.sin(Date.now() * 0.0005) * 0.05;
  const lumeIntensity = modeBlend * 2.0 * lumeBreathe;
  lumeMeshes.forEach(m=>{
    m.material.emissive.copy(new THREE.Color(0x000000).lerp(lumeEmCol, modeBlend));
    // Kawthar candy buttons: cap glow to prevent blowout
    m.material.emissiveIntensity = m.userData?.kawtharButton ? lumeIntensity * 0.7 : lumeIntensity;
  });
  if(hLumeMat_) { hLumeMat_.emissive.lerp(lumeEmCol, modeBlend); hLumeMat_.emissiveIntensity = lumeIntensity; }
  if(mLumeMat_) { mLumeMat_.emissive.lerp(lumeEmCol, modeBlend); mLumeMat_.emissiveIntensity = lumeIntensity; }
  
  // Numerals glow
  numeralMats.forEach(m=>{
    m.emissive.copy(new THREE.Color(0x000000).lerp(lumeEmCol, modeBlend));
    m.emissiveIntensity = lumeIntensity * 0.85;
  });
  
  // Dial surface picks up faint lume ambient bounce
  if(dialMesh && dialMesh.material) {
    const dayColor = new THREE.Color(DIALS[currentDial].bg);
    const nightDialColor = dayColor.clone().lerp(new THREE.Color(0x080810), modeBlend * 0.92);
    dialMesh.material.color.copy(nightDialColor);
    if(dialMesh.material.emissive) { // PBR materials only (kawthar, qamar)
      dialMesh.material.emissive.copy(lumeEmCol).multiplyScalar(0.08);
      dialMesh.material.emissiveIntensity = modeBlend;
    }
  }
  // Darken lower dial too
  if(dialLowerMesh && dialLowerMesh.material) {
    const dayLower = new THREE.Color(DIALS[currentDial].bg).multiplyScalar(0.75);
    dialLowerMesh.material.color.copy(dayLower.lerp(new THREE.Color(0x060608), modeBlend * 0.9));
  }
  
  // Rainbow bezel gems glow at night
  bezelMeshes.forEach(m => {
    if(m.material && m.material.emissiveIntensity !== undefined && m.material.ior) {
      m.material.emissiveIntensity = 0.1 + modeBlend * 0.6;
    }
  });
  
  // Qibla compass elements glow at night
  if(qiblaGroup) {
    qiblaGroup.traverse(child => {
      if(child.material && child.material.emissive) {
        if(child.material === window._qiblaTriMat) {
          // Qibla green triangle — strong glow
          child.material.emissiveIntensity = 0.15 + modeBlend * 1.0;
        } else if(child.material.emissiveIntensity !== undefined) {
          // Compass ticks — subtle lume glow
          child.material.emissiveIntensity = modeBlend * 0.5;
        }
      }
    });
  }
  
  // Ring segments glow with lume at night
  if(window._subdialRings) {
    window._subdialRings.forEach(r => {
      r.group.children.forEach(child => {
        if(child.material && child.material.userData && child.material.userData.fullColor) {
          const nightBoost = modeBlend * 0.5;
          child.material.emissiveIntensity = Math.max(child.material.emissiveIntensity, nightBoost);
        }
      });
    });
  }
  
  // Bloom ramps up in night mode — soft, dreamy glow
  bloomPass.strength = modeBlend * 0.8;
  bloomPass.radius = 0.4 + modeBlend * 0.3;
  bloomPass.threshold = 0.85 - modeBlend * 0.25; // floor 0.6 — only hottest emissives bloom
  
  // Dim scene lights for night — let lume own the scene
  ambLight.intensity = 0.06 * (1 - modeBlend * 0.85);
  keyLight.intensity = 1.0 * (1 - modeBlend * 0.85);
  specPoint.intensity = 3 * (1 - modeBlend * 0.7);
  counterSpec.intensity = 1.0 * (1 - modeBlend * 0.7);
  subSpot.intensity = 8 * (1 - modeBlend * 0.5);
  // Reduce env intensity at night so lume glows dominate
  if(scene.environmentIntensity !== undefined) scene.environmentIntensity = 0.6 * (1 - modeBlend * 0.7);
  renderer.toneMappingExposure = 1.0 - modeBlend * 0.35;
  
  // Vignette at night
  vignetteEl.style.opacity = modeBlend * 0.8;
  
  // Second hand subtle glow at night
  if(secMat_) secMat_.emissiveIntensity = modeBlend * 0.3;
  
  // Hands catch faint lume-tinted spec at night (simulates lume bounce on polished steel)
  if(hourMat_) { hourMat_.emissive = hourMat_.emissive || new THREE.Color(0); hourMat_.emissive.copy(lumeEmCol).multiplyScalar(0.04); hourMat_.emissiveIntensity = modeBlend; }
  if(minMat_) { minMat_.emissive = minMat_.emissive || new THREE.Color(0); minMat_.emissive.copy(lumeEmCol).multiplyScalar(0.04); minMat_.emissiveIntensity = modeBlend; }
  
  // Stars — staggered fade-in, tinted to lume palette
  starMeshes.forEach((m,i)=>{
    const s=m.userData;if(!s)return;
    // Stagger: each star appears at a different modeBlend threshold
    const starThreshold = 0.2 + (i / starMeshes.length) * 0.25; // 0.2 → 0.45 — all visible by modeBlend 0.6
    const starBlend = Math.max(0, Math.min(1, (modeBlend - starThreshold) / 0.15));
    const twinkle = (Math.sin(Date.now()*s.speed+s.offset)*0.3+0.7);
    m.material.opacity = starBlend * s.bright * twinkle;
    // Stars gently scale in
    const sc = 0.6 + starBlend * 0.4;
    m.scale.setScalar(sc);
    const starCol = new THREE.Color(2.2, 2.2, 1.9); // HDR for bloom pickup
    starCol.lerp(new THREE.Color(lumeEmCol).multiplyScalar(1.5), modeBlend * 0.3);
    m.material.color.copy(starCol);
  });
  
  // Moon — rises from below, reaches position at full night
  if(moonGroup) {
    const moonThreshold = 0.3; // moon starts rising after stars begin
    const moonBlend = Math.max(0, Math.min(1, (modeBlend - moonThreshold) / 0.5));
    moonGroup.visible = modeBlend > 0.1;
    
    // Rise from below-right to upper-right
    const startY = -60, endY = 80;   // above the star arc
    const startX = 0, endX = 0;     // centered — moon crowns the prostration arc
    // Ease-out cubic for natural rise
    const eased = 1 - Math.pow(1 - moonBlend, 3);
    moonGroup.position.y = startY + (endY - startY) * eased;
    moonGroup.position.x = startX + (endX - startX) * eased;
    
    // Moon glow and emissive
    if(moonMesh) {
      moonMesh.material.opacity = moonBlend;
      // HDR moon tinted slightly toward lume
      const mc = new THREE.Color(1.15, 1.12, 1.05);
      mc.lerp(new THREE.Color(lumeEmCol).multiplyScalar(0.8), 0.1);
      moonMesh.material.color.copy(mc);
    }
    if(moonGlowMesh) {
      moonGlowMesh.material.opacity = moonBlend * 0.15;
      const gc = new THREE.Color(1.2, 1.15, 1.0);
      gc.lerp(new THREE.Color(lumeEmCol).multiplyScalar(1.2), 0.2);
      moonGlowMesh.material.color.copy(gc);
    }
    
    // Moon phase: TODO — canvas texture approach for proper crescent
  }
  
  // BG color blend
  const nightBg = new THREE.Color(DIALS[currentDial].bg).lerp(new THREE.Color(0x0a0e18), modeBlend); // deep midnight — not void black
  if(!EMBED) scene.background = nightBg;
  bgPlaneMat.color.copy(nightBg);
  
  // Parallax + interactive spec light
  gx+=(tgx-gx)*0.08; gy+=(tgy-gy)*0.08;
  // gyro debug dot removed
  // Camera stays fixed — no parallax (Tawfeeq preference)
  cam.position.x = 0;
  cam.position.y = -3;
  cam.lookAt(0,0,0);
  
  // HDRI rotation with tilt — softboxes sweep across hands from pleasing rest position
  if(scene.environmentRotation) {
    scene.environmentRotation.y = 0.3 + gx * 0.6;  // base offset + tilt sweep
    scene.environmentRotation.x = 0.1 + gy * 0.3;
  }
  // Spec point follows tilt — the main visible highlight on hands
  specPoint.position.x = 30 + gx * 120;  // wider travel
  specPoint.position.y = 60 + gy * 90;
  // Subdial spot follows tilt
  subSpot.position.x = 10 + gx * 70;
  subSpot.position.y = -R*0.5 + 30 + gy * 50;
  // Counter spec — opposite dance for depth
  counterSpec.position.x = -40 - gx * 90;
  counterSpec.position.y = -30 - gy * 50;
  
  updateHands();
  updateFlap();
  updateQibla();
  // Spin subdial rings — wild when off Qibla, decelerate and lock when aligned
  if(window._subdialRings && qiblaRotor) {
    const qiblaOffset = ((qiblaBearing - compassHeading) % 360 + 360) % 360;
    const offNorm = Math.min(qiblaOffset, 360 - qiblaOffset) / 180; // 0=aligned, 1=opposite
    const aligned = qiblaAligned;
    const nearZone = offNorm < 0.15; // within ~27° — rings start slowing
    
    // Qibla triangle pulses when aligned
    if(window._qiblaTriMat) {
      const targetTri = aligned ? 0.6 + Math.sin(Date.now() * 0.005) * 0.2 : 0.15;
      window._qiblaTriMat.emissiveIntensity += (targetTri - window._qiblaTriMat.emissiveIntensity) * 0.1;
    }
    
    window._subdialRings.forEach(r => {
      if(aligned) {
        // Snap to nearest aligned position (nearest multiple of segment angle)
        const segAngle = Math.PI * 2 / 8;
        const nearest = Math.round(r.group.rotation.z / segAngle) * segAngle;
        r.group.rotation.z += (nearest - r.group.rotation.z) * 0.12; // firm snap
      } else {
        // Continuous spin — speed proportional to offset, slows as you approach
        const spinSpeed = offNorm * offNorm * r.speed * r.dir * 0.04; // quadratic falloff
        r.group.rotation.z += spinSpeed;
      }
      
      // Color shift: desaturated while spinning → vivid + glow on alignment
      r.group.children.forEach(child => {
        if(child.material && child.material.userData) {
          const { fullColor, dimColor } = child.material.userData;
          const targetEmissive = aligned ? 0.4 : (nearZone ? 0.1 : 0);
          child.material.emissiveIntensity += (targetEmissive - child.material.emissiveIntensity) * 0.08;
          // Lerp base color: dim → full
          const colorTarget = aligned ? fullColor : (nearZone ? fullColor.clone().lerp(dimColor, 0.5) : dimColor);
          child.material.color.lerp(colorTarget, 0.06);
        }
      });
    });
  }
  
  const bgHex = '#'+bgPlaneMat.color.getHexString();
  document.querySelector('meta[name="theme-color"]').content=bgHex;
  document.documentElement.style.background = document.body.style.background = bgHex; // keep notch/Dynamic Island synced
  
  // Use composer for bloom; in embed+night, render dark bg (no alpha)
  if(modeBlend > 0.01) {
    composer.render();
  } else {
    renderer.render(scene, cam);
  }
}
animate();
if(EMBED){
  document.getElementById('info').style.display='none';
  document.getElementById('dialBar').style.display='none';
} else {
  showInfo();
}

</script>
</body>
</html>
